#!/usr/bin/env bash
set -euo pipefail

STATE_ROOT="${XDG_STATE_HOME:-$HOME/.local/state}/gh-router"
PROFILE_ROOT="${GH_ROUTER_PROFILE_ROOT:-$STATE_ROOT/profiles}"
CACHE_ROOT="${GH_ROUTER_CACHE_ROOT:-$STATE_ROOT/cache}"
ORG_CACHE_DIR="${GH_ROUTER_ORG_CACHE_DIR:-$CACHE_ROOT/orgs}"
GLOBAL_GH_CONFIG_DIR="${GH_ROUTER_GLOBAL_GH_CONFIG_DIR:-${XDG_CONFIG_HOME:-$HOME/.config}/gh}"
DEFAULT_ACCOUNT="${GH_ROUTER_DEFAULT_ACCOUNT:-}"
ORG_CACHE_TTL="${GH_ROUTER_ORG_CACHE_TTL:-86400}"

GHQ_ROOT_CACHE=""
AUTH_STATUS_JSON_CACHE=""
VERBOSE=0

verbose_log() {
  (( VERBOSE )) || return 0
  printf "[gh-router] %s\n" "$*" >&2
}

ensure_dirs() {
  mkdir -p -m 700 "$PROFILE_ROOT" "$CACHE_ROOT" "$ORG_CACHE_DIR"
}

profile_dir() {
  printf "%s/%s\n" "$PROFILE_ROOT" "$1"
}

profile_exists() {
  local account="$1"
  local dir

  dir="$(profile_dir "$account")"
  [[ -f "$dir/hosts.yml" ]]
}

auth_status_json() {
  if [[ -n "$AUTH_STATUS_JSON_CACHE" ]]; then
    printf "%s\n" "$AUTH_STATUS_JSON_CACHE"
    return 0
  fi

  command -v gh >/dev/null 2>&1 || return 1
  command -v jq >/dev/null 2>&1 || return 1

  AUTH_STATUS_JSON_CACHE="$(GH_CONFIG_DIR="$GLOBAL_GH_CONFIG_DIR" gh auth status --json hosts 2>/dev/null || true)"
  [[ -n "$AUTH_STATUS_JSON_CACHE" ]] || return 1

  printf "%s\n" "$AUTH_STATUS_JSON_CACHE"
}

auth_status_accounts() {
  local json

  json="$(auth_status_json 2>/dev/null || true)"
  [[ -n "$json" ]] || return 1

  jq -r '.hosts["github.com"][]?.login // empty' <<< "$json"
}

auth_status_git_protocol_for_account() {
  local account="$1"
  local json protocol

  json="$(auth_status_json 2>/dev/null || true)"
  [[ -n "$json" ]] || return 1

  protocol="$(jq -r --arg account "$account" '.hosts["github.com"][]? | select(.login == $account) | (.gitProtocol // "https")' <<< "$json" | tr -d '\r' || true)"
  [[ -n "$protocol" ]] || return 1

  printf "%s\n" "$protocol"
}

ensure_profile_for_account() {
  local account="$1"
  local dir protocol

  profile_exists "$account" && return 0

  protocol="$(auth_status_git_protocol_for_account "$account" 2>/dev/null || true)"
  [[ -n "$protocol" ]] || return 1

  ensure_dirs
  dir="$(profile_dir "$account")"
  mkdir -p -m 700 "$dir"

  cat > "$dir/hosts.yml" <<EOF
github.com:
    users:
        $account:
    user: $account
    git_protocol: $protocol
EOF
  chmod 600 "$dir/hosts.yml"
}

hydrate_profiles_from_auth_status() {
  local account

  while IFS= read -r account; do
    [[ -n "$account" ]] || continue
    ensure_profile_for_account "$account" >/dev/null 2>&1 || true
  done < <(auth_status_accounts 2>/dev/null || true)
}

has_any_profile() {
  local dir
  for dir in "$PROFILE_ROOT"/*/hosts.yml; do
    [[ -f "$dir" ]] && return 0
  done
  return 1
}

list_accounts() {
  local dir

  has_any_profile || hydrate_profiles_from_auth_status

  for dir in "$PROFILE_ROOT"/*; do
    [[ -d "$dir" ]] || continue
    [[ -f "$dir/hosts.yml" ]] || continue
    basename "$dir"
  done | LC_ALL=C sort
}

ghq_root() {
  if [[ -n "$GHQ_ROOT_CACHE" ]]; then
    printf "%s\n" "$GHQ_ROOT_CACHE"
    return 0
  fi

  command -v ghq >/dev/null 2>&1 || return 1
  GHQ_ROOT_CACHE="$(ghq root 2>/dev/null || true)"
  [[ -n "$GHQ_ROOT_CACHE" ]] || return 1

  printf "%s\n" "$GHQ_ROOT_CACHE"
}

owner_from_ghq_path() {
  local dir="${1:-$PWD}"
  local root prefix rel owner

  root="$(ghq_root 2>/dev/null || true)"
  [[ -n "$root" ]] || return 1

  prefix="${root%/}/github.com/"
  [[ "$dir" == "$prefix"* ]] || return 1

  rel="${dir#$prefix}"
  owner="${rel%%/*}"
  [[ -n "$owner" ]] || return 1

  printf "%s\n" "$owner"
}

owner_from_remote_url() {
  local remote_url="$1"
  local path owner

  [[ -n "$remote_url" ]] || return 1

  case "$remote_url" in
    git@github.com:*)
      path="${remote_url#git@github.com:}"
      ;;
    ssh://git@github.com/*)
      path="${remote_url#ssh://git@github.com/}"
      ;;
    https://github.com/*)
      path="${remote_url#https://github.com/}"
      ;;
    http://github.com/*)
      path="${remote_url#http://github.com/}"
      ;;
    *)
      return 1
      ;;
  esac

  path="${path%.git}"
  owner="${path%%/*}"
  [[ -n "$owner" ]] || return 1
  [[ "$owner" != "$path" ]] || return 1

  printf "%s\n" "$owner"
}

owner_from_git_origin() {
  local dir="${1:-$PWD}"
  local remote_url

  command -v git >/dev/null 2>&1 || return 1
  remote_url="$(git -C "$dir" remote get-url origin 2>/dev/null || true)"
  [[ -n "$remote_url" ]] || return 1

  owner_from_remote_url "$remote_url"
}

owner_from_credential_path() {
  local path="$1"
  local owner

  [[ -n "$path" ]] || return 1

  path="${path#/}"
  path="${path%.git}"
  owner="${path%%/*}"
  [[ -n "$owner" ]] || return 1
  [[ "$owner" != "$path" ]] || return 1

  printf "%s\n" "$owner"
}

now_epoch() {
  date +%s
}

orgs_cache_file_for_account() {
  printf "%s/%s.tsv\n" "$ORG_CACHE_DIR" "$1"
}

orgs_cache_get() {
  local account="$1"
  local cache_file now expires

  cache_file="$(orgs_cache_file_for_account "$account")"
  [[ -f "$cache_file" ]] || return 1

  IFS=$'\t' read -r expires < "$cache_file"
  [[ "$expires" =~ ^[0-9]+$ ]] || return 1
  now="$(now_epoch)"
  (( expires > now )) || return 1

  tail -n +2 "$cache_file"
}

orgs_cache_set() {
  local account="$1"
  shift
  local cache_file expires

  ensure_dirs
  expires=$(( $(now_epoch) + ORG_CACHE_TTL ))
  cache_file="$(orgs_cache_file_for_account "$account")"

  {
    printf "%s\n" "$expires"
    for org in "$@"; do
      printf "%s\n" "$org"
    done
  } > "$cache_file"
  chmod 600 "$cache_file"
}

orgs_for_account() {
  local account="$1"
  local profile orgs_raw

  orgs_cache_get "$account" 2>/dev/null && return 0

  profile="$(profile_dir "$account")"
  [[ -f "$profile/hosts.yml" ]] || return 1

  orgs_raw="$(GH_CONFIG_DIR="$profile" gh api /user/orgs --jq '.[].login' 2>/dev/null || true)"
  [[ -n "$orgs_raw" ]] || { orgs_cache_set "$account"; return 1; }

  local -a org_list
  mapfile -t org_list <<< "$orgs_raw"
  orgs_cache_set "$account" "${org_list[@]}"
  printf "%s\n" "${org_list[@]}"
}

fallback_account() {
  if [[ -n "$DEFAULT_ACCOUNT" ]] && { profile_exists "$DEFAULT_ACCOUNT" || ensure_profile_for_account "$DEFAULT_ACCOUNT"; }; then
    printf "%s\n" "$DEFAULT_ACCOUNT"
    return 0
  fi

  return 1
}

resolve_account_for_owner() {
  local owner="$1"
  local account

  verbose_log "resolve owner=$owner"

  if profile_exists "$owner"; then
    verbose_log "step 1: owner-profile match -> $owner"
    printf "%s\t%s\n" "$owner" "owner-profile"
    return 0
  fi
  verbose_log "step 1: owner-profile match? no"

  local org_line orgs_list
  while IFS= read -r account; do
    [[ -n "$account" ]] || continue
    orgs_list=""
    while IFS= read -r org_line; do
      [[ -n "$org_line" ]] || continue
      orgs_list="${orgs_list:+$orgs_list,}$org_line"
      if [[ "$org_line" == "$owner" ]]; then
        verbose_log "step 2: probe $account orgs=[$orgs_list] -> MATCH"
        printf "%s\t%s\n" "$account" "org-membership"
        return 0
      fi
    done < <(orgs_for_account "$account" 2>/dev/null || true)
    verbose_log "step 2: probe $account orgs=[$orgs_list] -> no match"
  done < <(list_accounts)

  verbose_log "step 3: no account resolved, falling back"
  return 1
}

resolve_context_for_cwd() {
  local cwd="$1"
  local owner=""
  local account reason fallback

  verbose_log "cwd=$cwd"

  owner="$(owner_from_ghq_path "$cwd" 2>/dev/null || true)"
  if [[ -n "$owner" ]]; then
    verbose_log "owner=$owner (source: ghq-path)"
  else
    owner="$(owner_from_git_origin "$cwd" 2>/dev/null || true)"
    if [[ -n "$owner" ]]; then
      verbose_log "owner=$owner (source: git-origin)"
    else
      verbose_log "owner not detected"
    fi
  fi

  if [[ -n "$owner" ]]; then
    if IFS=$'\t' read -r account reason <<< "$(resolve_account_for_owner "$owner")"; then
      if [[ -n "$account" ]]; then
        verbose_log "result: account=$account reason=$reason"
        printf "%s\t%s\t%s\n" "$owner" "$account" "$reason"
        return 0
      fi
    fi

    fallback="$(fallback_account 2>/dev/null || true)"
    if [[ -n "$fallback" ]]; then
      verbose_log "result: account=$fallback reason=fallback-default"
      printf "%s\t%s\t%s\n" "$owner" "$fallback" "fallback-default"
      return 0
    fi

    verbose_log "result: unresolved"
    printf "%s\t%s\t%s\n" "$owner" "-" "owner-unresolved"
    return 1
  fi

  fallback="$(fallback_account 2>/dev/null || true)"
  if [[ -n "$fallback" ]]; then
    verbose_log "result: account=$fallback reason=fallback-default (no owner)"
    printf "%s\t%s\t%s\n" "" "$fallback" "fallback-default"
    return 0
  fi

  verbose_log "result: outside-repo"
  printf "%s\t%s\t%s\n" "" "-" "outside-repo"
  return 1
}

resolve_context_for_credential() {
  local path="$1"
  local owner=""
  local account reason fallback

  owner="$(owner_from_credential_path "$path" 2>/dev/null || true)"
  if [[ -n "$owner" ]]; then
    if IFS=$'\t' read -r account reason <<< "$(resolve_account_for_owner "$owner" 2>/dev/null || true)"; then
      if [[ -n "$account" ]]; then
        printf "%s\t%s\t%s\n" "$owner" "$account" "$reason"
        return 0
      fi
    fi

    fallback="$(fallback_account 2>/dev/null || true)"
    if [[ -n "$fallback" ]]; then
      printf "%s\t%s\t%s\n" "$owner" "$fallback" "fallback-default"
      return 0
    fi

    printf "%s\t%s\t%s\n" "$owner" "-" "credential-owner-unresolved"
    return 1
  fi

  fallback="$(fallback_account 2>/dev/null || true)"
  if [[ -n "$fallback" ]]; then
    printf "%s\t%s\t%s\n" "" "$fallback" "fallback-default"
    return 0
  fi

  printf "%s\t%s\t%s\n" "" "-" "credential-path-missing"
  return 1
}

is_strict_resolution_reason() {
  local reason="$1"

  case "$reason" in
    owner-profile|org-membership|org-cache)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

git_repo_root() {
  local cwd="${1:-$PWD}"
  local root

  command -v git >/dev/null 2>&1 || return 1
  root="$(git -C "$cwd" rev-parse --show-toplevel 2>/dev/null || true)"
  [[ -n "$root" ]] || return 1

  printf "%s\n" "$root"
}

identity_cache_file_for_account() {
  printf "%s/identity/%s.tsv\n" "$CACHE_ROOT" "$1"
}

identity_cache_get() {
  local account="$1"
  local cache_file expires now name email

  cache_file="$(identity_cache_file_for_account "$account")"
  [[ -f "$cache_file" ]] || return 1

  {
    IFS=$'\t' read -r expires
    IFS=$'\t' read -r name email
  } < "$cache_file"

  [[ "$expires" =~ ^[0-9]+$ ]] || return 1
  now="$(now_epoch)"
  (( expires > now )) || return 1
  [[ -n "$name" && -n "$email" ]] || return 1

  printf "%s\t%s\n" "$name" "$email"
}

identity_cache_set() {
  local account="$1"
  local name="$2"
  local email="$3"
  local cache_file expires

  mkdir -p -m 700 "$CACHE_ROOT/identity"
  expires=$(( $(now_epoch) + ORG_CACHE_TTL ))
  cache_file="$(identity_cache_file_for_account "$account")"

  printf "%s\n%s\t%s\n" "$expires" "$name" "$email" > "$cache_file"
  chmod 600 "$cache_file"
}

identity_for_account() {
  local account="$1"
  local cached

  cached="$(identity_cache_get "$account" 2>/dev/null || true)"
  if [[ -n "$cached" ]]; then
    printf "%s\n" "$cached"
    return 0
  fi

  local profile raw name login email user_id
  local sep=$'\x1f'

  profile="$(profile_dir "$account")"
  [[ -f "$profile/hosts.yml" ]] || return 1

  raw="$(
    GH_CONFIG_DIR="$profile" \
      gh api /user --jq '[.name // "", .login // "", .email // "", (.id | tostring)] | join("\u001f")' 2>/dev/null || true
  )"
  [[ -n "$raw" ]] || return 1

  IFS="$sep" read -r name login email user_id <<< "$raw"
  [[ -n "$login" ]] || return 1

  if [[ -z "$name" ]]; then
    name="$login"
  fi

  if [[ -z "$email" ]]; then
    [[ -n "$user_id" ]] || return 1
    email="${user_id}+${login}@users.noreply.github.com"
  fi

  identity_cache_set "$account" "$name" "$email"
  printf "%s\t%s\n" "$name" "$email"
}

apply_zsh_exports() {
  local account="$1"
  local owner="$2"
  local reason="$3"
  local dir

  if [[ "$account" != "-" ]] && [[ -n "$account" ]] && { profile_exists "$account" || ensure_profile_for_account "$account"; }; then
    dir="$(profile_dir "$account")"
    printf "export GH_CONFIG_DIR=%q\n" "$dir"
    printf "export GH_ROUTER_ACTIVE_ACCOUNT=%q\n" "$account"
    printf "export GH_ROUTER_LAST_REASON=%q\n" "$reason"
    if [[ -n "$owner" ]]; then
      printf "export GH_ROUTER_ACTIVE_OWNER=%q\n" "$owner"
    else
      printf "unset GH_ROUTER_ACTIVE_OWNER\n"
    fi
  else
    printf "unset GH_CONFIG_DIR\n"
    printf "unset GH_ROUTER_ACTIVE_ACCOUNT\n"
    printf "unset GH_ROUTER_ACTIVE_OWNER\n"
    printf "unset GH_ROUTER_LAST_REASON\n"
  fi
}

command_apply() {
  local shell="zsh"
  local cwd="$PWD"
  local owner="" account="-" reason="outside-repo"
  local line

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --shell)
        shell="$2"
        shift 2
        ;;
      --cwd)
        cwd="$2"
        shift 2
        ;;
      *)
        echo "unknown option: $1" >&2
        return 1
        ;;
    esac
  done

  line="$(resolve_context_for_cwd "$cwd" 2>/dev/null || true)"
  if [[ -n "$line" ]]; then
    IFS=$'\t' read -r owner account reason <<< "$line"
  fi

  case "$shell" in
    zsh)
      apply_zsh_exports "$account" "$owner" "$reason"
      ;;
    *)
      echo "unsupported shell: $shell" >&2
      return 1
      ;;
  esac
}

command_status() {
  local cwd="$PWD"
  local owner="" account="-" reason="outside-repo"
  local profile="N/A"
  local line

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --cwd)
        cwd="$2"
        shift 2
        ;;
      --verbose)
        VERBOSE=1
        shift
        ;;
      *)
        echo "unknown option: $1" >&2
        return 1
        ;;
    esac
  done

  if (( VERBOSE )); then
    line="$(resolve_context_for_cwd "$cwd" || true)"
  else
    line="$(resolve_context_for_cwd "$cwd" 2>/dev/null || true)"
  fi
  if [[ -n "$line" ]]; then
    IFS=$'\t' read -r owner account reason <<< "$line"
  fi

  if [[ "$account" != "-" ]] && [[ -n "$account" ]]; then
    profile="$(profile_dir "$account")"
  fi

  echo "cwd_owner=${owner:-N/A}"
  echo "resolved_account=${account:--}"
  echo "resolved_profile=${profile}"
  echo "reason=${reason:-N/A}"
  echo "default_account=${DEFAULT_ACCOUNT:-N/A}"
  echo "org_cache_dir=${ORG_CACHE_DIR}"
  echo "org_cache_ttl=${ORG_CACHE_TTL}"
}

command_login() {
  local account="${1:-}"
  local dir

  [[ -n "$account" ]] || {
    echo "usage: gh-router login <account> [gh auth login options...]" >&2
    return 1
  }

  shift
  ensure_dirs
  dir="$(profile_dir "$account")"
  mkdir -p -m 700 "$dir"

  GH_CONFIG_DIR="$dir" gh auth login "$@"
  rm -rf "$ORG_CACHE_DIR"
  rm -rf "$CACHE_ROOT/identity"
  ensure_dirs
}

command_clear_cache() {
  rm -rf "$ORG_CACHE_DIR"
  rm -rf "$CACHE_ROOT/identity"
  ensure_dirs
}

command_sync_identity() {
  local cwd="$PWD"
  local repo
  local owner="" account="-" reason="outside-repo"
  local line identity name email

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --cwd)
        cwd="$2"
        shift 2
        ;;
      *)
        echo "unknown option: $1" >&2
        return 1
        ;;
    esac
  done

  repo="$(git_repo_root "$cwd" 2>/dev/null || true)"
  [[ -n "$repo" ]] || return 0

  line="$(resolve_context_for_cwd "$cwd" 2>/dev/null || true)"
  if [[ -n "$line" ]]; then
    IFS=$'\t' read -r owner account reason <<< "$line"
  fi

  [[ -n "$owner" ]] || return 0
  [[ "$account" != "-" ]] && [[ -n "$account" ]] || return 0
  is_strict_resolution_reason "$reason" || return 0
  { profile_exists "$account" || ensure_profile_for_account "$account"; } || return 0

  identity="$(identity_for_account "$account" 2>/dev/null || true)"
  [[ -n "$identity" ]] || return 0

  IFS=$'\t' read -r name email <<< "$identity"
  [[ -n "$name" ]] || return 0
  [[ -n "$email" ]] || return 0

  git -C "$repo" config --local user.name "$name"
  git -C "$repo" config --local user.email "$email"
}

command_credential() {
  local op="${1:-get}"
  local input_file
  local host=""
  local path=""
  local owner="" account="-" reason=""
  local line

  case "$op" in
    get|store|erase)
      ;;
    *)
      echo "usage: gh-router credential [get|store|erase]" >&2
      return 1
      ;;
  esac

  input_file="$(mktemp)"
  trap 'if [[ -n "${input_file:-}" ]]; then rm -f "$input_file"; fi' EXIT
  cat > "$input_file"

  while IFS='=' read -r key value; do
    case "$key" in
      host)
        host="$value"
        ;;
      path)
        path="$value"
        ;;
    esac
  done < "$input_file"

  if [[ -n "$host" ]] && [[ "$host" != "github.com" ]]; then
    gh auth git-credential "$op" < "$input_file"
    return $?
  fi

  line="$(resolve_context_for_credential "$path" 2>/dev/null || true)"
  if [[ -n "$line" ]]; then
    IFS=$'\t' read -r owner account reason <<< "$line"
  fi

  if [[ "$account" != "-" ]] && [[ -n "$account" ]] && { profile_exists "$account" || ensure_profile_for_account "$account"; }; then
    GH_CONFIG_DIR="$(profile_dir "$account")" gh auth git-credential "$op" < "$input_file"
  else
    gh auth git-credential "$op" < "$input_file"
  fi
}

command_doctor() {
  local has_error=0
  local account profile login token
  local -A tokens=()

  while IFS= read -r account; do
    [[ -n "$account" ]] || continue
    profile="$(profile_dir "$account")"

    # check profile exists
    if [[ ! -f "$profile/hosts.yml" ]]; then
      echo "[FAIL] profile $account: hosts.yml missing"
      has_error=1
      continue
    fi

    # check directory permissions
    local dir_perms file_perms
    dir_perms="$(stat -c %a "$profile" 2>/dev/null || true)"
    file_perms="$(stat -c %a "$profile/hosts.yml" 2>/dev/null || true)"
    if [[ "$dir_perms" != "700" ]]; then
      echo "[WARN] profile $account: directory permissions $dir_perms (expected 700)"
    fi
    if [[ "$file_perms" != "600" ]]; then
      echo "[WARN] profile $account: hosts.yml permissions $file_perms (expected 600)"
    fi

    # check token works and returns expected login
    login="$(GH_CONFIG_DIR="$profile" gh api /user --jq .login 2>/dev/null || true)"
    if [[ -z "$login" ]]; then
      echo "[FAIL] profile $account: token invalid (gh api /user failed)"
      has_error=1
      continue
    fi
    if [[ "$login" != "$account" ]]; then
      echo "[FAIL] profile $account: token returns login=$login (expected $account)"
      has_error=1
      continue
    fi
    echo "[OK]   profile $account: token valid, login=$login"

    # collect token hash for isolation check
    token="$(GH_CONFIG_DIR="$profile" gh auth token 2>/dev/null | sha256sum | cut -d' ' -f1 || true)"
    if [[ -n "$token" ]]; then
      tokens["$account"]="$token"
    fi
  done < <(list_accounts)

  # check token isolation
  local -a token_values=()
  local k
  for k in "${!tokens[@]}"; do
    token_values+=("${tokens[$k]}")
  done
  if (( ${#token_values[@]} >= 2 )); then
    local -A unique=()
    for t in "${token_values[@]}"; do
      unique["$t"]=1
    done
    if (( ${#unique[@]} == ${#token_values[@]} )); then
      echo "[OK]   tokens isolated (different per profile)"
    else
      echo "[FAIL] tokens NOT isolated (some profiles share the same token)"
      has_error=1
    fi
  fi

  # check credential helper
  local cred_helper
  cred_helper="$(git config --global 'credential.https://github.com.helper' 2>/dev/null || true)"
  if [[ "$cred_helper" == *"gh-router"*"credential"* ]]; then
    echo "[OK]   credential helper registered"
  else
    echo "[WARN] credential helper not registered in git config"
  fi

  return $has_error
}

command_resolve() {
  local cwd="$PWD"
  local owner="" account="-" reason="outside-repo"
  local line

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --cwd)
        cwd="$2"
        shift 2
        ;;
      --verbose)
        VERBOSE=1
        shift
        ;;
      *)
        echo "unknown option: $1" >&2
        return 1
        ;;
    esac
  done

  if (( VERBOSE )); then
    line="$(resolve_context_for_cwd "$cwd" || true)"
  else
    line="$(resolve_context_for_cwd "$cwd" 2>/dev/null || true)"
  fi
  if [[ -n "$line" ]]; then
    IFS=$'\t' read -r owner account reason <<< "$line"
  fi

  echo "owner=${owner:-N/A}"
  if [[ "$account" == "-" || -z "$account" ]]; then
    echo "account=N/A"
  else
    echo "account=$account"
  fi
  echo "reason=${reason:-N/A}"

  [[ "$account" != "-" ]] && [[ -n "$account" ]]
}

main() {
  local cmd="${1:-}"

  ensure_dirs
  case "$cmd" in
    apply)
      shift
      command_apply "$@"
      ;;
    status)
      shift
      command_status "$@"
      ;;
    resolve)
      shift
      command_resolve "$@"
      ;;
    login)
      shift
      command_login "$@"
      ;;
    clear-cache)
      shift
      command_clear_cache "$@"
      ;;
    sync-identity)
      shift
      command_sync_identity "$@"
      ;;
    credential)
      shift
      command_credential "$@"
      ;;
    doctor)
      shift
      command_doctor "$@"
      ;;
    *)
      cat <<'EOF' >&2
usage: gh-router <command> [args]

commands:
  apply --shell zsh [--cwd PATH]
  status [--cwd PATH] [--verbose]
  resolve [--cwd PATH] [--verbose]
  login <account> [gh auth login options...]
  clear-cache
  sync-identity [--cwd PATH]
  credential [get|store|erase]
  doctor

notes:
  - stateless resolver: no session/account state
  - org resolution via /user/orgs cached per account with TTL
  - profiles auto-generated from gh auth status
EOF
      return 1
      ;;
  esac
}

main "$@"
